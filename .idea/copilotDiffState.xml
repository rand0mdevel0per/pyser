<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/cpp/pyser.cpp">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/cpp/pyser.cpp" />
              <option name="originalContent" value="// pyser.cpp&#10;#include &quot;pyser.hpp&quot;&#10;#include &lt;openssl/sha.h&gt;&#10;#include &lt;nlohmann/json.hpp&gt;&#10;#include &lt;cppcodec/base64_rfc4648.hpp&gt;&#10;#include &lt;Python.h&gt;&#10;&#10;namespace pyser {&#10;    using json = nlohmann::json;&#10;    using base64 = cppcodec::base64_rfc4648;&#10;&#10;&#10;    std::vector&lt;DataChunk&gt; PyObjectSerializer::create_chunks(&#10;        const std::vector&lt;uint8_t&gt; &amp;data&#10;    ) {&#10;        std::vector&lt;DataChunk&gt; chunks;&#10;        size_t offset = 0;&#10;&#10;        while (offset &lt; data.size()) {&#10;            DataChunk chunk;&#10;            chunk.chunk_id = next_chunk_id_++;&#10;            size_t chunk_size = std::min(CHUNK_SIZE, data.size() - offset);&#10;            chunk.raw_data.assign(&#10;                data.begin() + offset,&#10;                data.begin() + offset + chunk_size&#10;            );&#10;            chunk.original_size = chunk_size;&#10;            chunk.base64_data = base64::encode(chunk.raw_data);&#10;            chunk.sha256_hash = compute_sha256(chunk.raw_data);&#10;            chunks.push_back(chunk);&#10;            offset += chunk_size;&#10;        }&#10;&#10;        return chunks;&#10;    }&#10;&#10;    std::string PyObjectSerializer::compute_sha256(const std::vector&lt;uint8_t&gt; &amp;data) {&#10;        unsigned char hash[SHA256_DIGEST_LENGTH];&#10;        SHA256(data.data(), data.size(), hash);&#10;        char hex[SHA256_DIGEST_LENGTH * 2 + 1];&#10;        for (int i = 0; i &lt; SHA256_DIGEST_LENGTH; i++) {&#10;            sprintf(hex + i * 2, &quot;%02x&quot;, hash[i]);&#10;        }&#10;        hex[SHA256_DIGEST_LENGTH * 2] = '\0';&#10;&#10;        return {hex};&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_bigint(PyObject *obj) {&#10;        SerializedNode node;&#10;        node.type = NodeType::INT;&#10;        node.meta.type_name = &quot;int&quot;;&#10;        node.meta.is_bigint = true;&#10;        // Diagnostic: ensure obj is a PyLong&#10;        if (!PyLong_Check(obj)) {&#10;            fprintf(stderr, &quot;pyser: serialize_bigint called with non-long type: %s\n&quot;, Py_TYPE(obj)-&gt;tp_name);&#10;        } else {&#10;            fprintf(stderr, &quot;pyser: serialize_bigint called on PyLong\n&quot;);&#10;        }&#10;        size_t n_bits = _PyLong_NumBits(obj);&#10;        size_t n_bytes = (n_bits + 7) / 8;&#10;        std::vector&lt;uint32_t&gt; digits;&#10;        auto *long_obj = reinterpret_cast&lt;PyLongObject *&gt;(obj);&#10;        std::vector&lt;uint8_t&gt; raw_data(n_bytes);&#10;        _PyLong_AsByteArray(long_obj, raw_data.data(), n_bytes, 1, 1, 1);&#10;        node.meta.bigint_num_digits = n_bytes;&#10;        node.chunks = create_chunks(raw_data);&#10;        return node;&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_int(PyObject *obj) {&#10;        SerializedNode node;&#10;        node.type = NodeType::INT;&#10;        node.meta.type_name = &quot;int&quot;;&#10;        node.meta.refcount = 1;&#10;        // Diagnostic: print incoming type info&#10;        if (obj) fprintf(stderr, &quot;pyser: serialize_int called on type: %s\n&quot;, Py_TYPE(obj)-&gt;tp_name);&#10;        int overflow;&#10;        long long value = PyLong_AsLongLongAndOverflow(obj, &amp;overflow);&#10;        if (overflow != 0) {&#10;            return serialize_bigint(obj);&#10;        }&#10;        node.meta.is_bigint = false;&#10;        std::vector&lt;uint8_t&gt; raw_data(sizeof(long long));&#10;        std::memcpy(raw_data.data(), &amp;value, sizeof(long long));&#10;        node.chunks = create_chunks(raw_data);&#10;        return node;&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_string(PyObject *obj) {&#10;        SerializedNode node;&#10;        node.type = NodeType::STRING;&#10;        node.meta.type_name = &quot;str&quot;;&#10;        node.meta.refcount = 1;&#10;        node.meta.has_dict = false;&#10;        Py_ssize_t size;&#10;        const char *data = PyUnicode_AsUTF8AndSize(obj, &amp;size);&#10;        std::vector&lt;uint8_t&gt; raw_data(data, data + size);&#10;        node.meta.total_size = size;&#10;        node.chunks = create_chunks(raw_data);&#10;        return node;&#10;    }&#10;&#10;    // Update signatures to accept owner node id for pointer population&#10;    SerializedNode PyObjectSerializer::serialize_container(&#10;        PyObject *obj,&#10;        NodeType type,&#10;        SerializedGraph &amp;graph,&#10;        std::unordered_map&lt;PyObject *, uint32_t&gt; &amp;visited,&#10;        int depth,&#10;        uint32_t owner_node_id&#10;    ) {&#10;        SerializedNode node;&#10;        node.type = type;&#10;        node.meta.refcount = 1;&#10;        Py_ssize_t size;&#10;        if (type == NodeType::LIST) {&#10;            size = PyList_Size(obj);&#10;            node.meta.type_name = &quot;list&quot;;&#10;        } else if (type == NodeType::TUPLE) {&#10;            size = PyTuple_Size(obj);&#10;            node.meta.type_name = &quot;tuple&quot;;&#10;        } else if (type == NodeType::SET) {&#10;            size = PySet_Size(obj);&#10;            node.meta.type_name = &quot;set&quot;;&#10;        } else {&#10;            PyErr_SetString(PyExc_TypeError, &quot;Unsupported container type&quot;);&#10;            node.meta.has_dict = false;&#10;            node.meta.total_size = 0;&#10;            return node;&#10;        }&#10;        node.meta.has_dict = false;&#10;        node.meta.total_size = size;&#10;        for (Py_ssize_t i = 0; i &lt; size; i++) {&#10;            PyObject *item = nullptr;&#10;            if (type == NodeType::LIST) {&#10;                item = PyList_GetItem(obj, i);&#10;            } else if (type == NodeType::TUPLE) {&#10;                item = PyTuple_GetItem(obj, i);&#10;            } else {&#10;                PyObject *iter = PyObject_GetIter(obj);&#10;                for (Py_ssize_t j = 0; j &lt;= i; j++) {&#10;                    item = PyIter_Next(iter);&#10;                }&#10;                Py_DECREF(iter);&#10;            }&#10;            if (!item) continue;&#10;            uint32_t child_id = serialize_recursive(item, graph, visited, depth + 1);&#10;            if (child_id == UINT32_MAX) {&#10;                return node;&#10;            }&#10;            PointerInfo ptr;&#10;            ptr.from_node_id = owner_node_id;&#10;            ptr.from_chunk_id = 0;&#10;            ptr.offset = i * sizeof(void *);&#10;            ptr.to_node_id = child_id;&#10;            ptr.field_name = std::to_string(i);&#10;            node.pointers.push_back(ptr);&#10;            graph.all_pointers.push_back(ptr);&#10;        }&#10;        return node;&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_float(PyObject *obj) {&#10;        SerializedNode node;&#10;        node.type = NodeType::FLOAT;&#10;        node.meta.type_name = &quot;float&quot;;&#10;        node.meta.refcount = 1;&#10;&#10;        if (!PyFloat_Check(obj)) {&#10;            PyErr_SetString(PyExc_TypeError, &quot;Expected a float object&quot;);&#10;            return node;&#10;        }&#10;&#10;        double value = PyFloat_AsDouble(obj);&#10;        std::vector raw_data(reinterpret_cast&lt;uint8_t *&gt;(&amp;value),&#10;                             reinterpret_cast&lt;uint8_t *&gt;(&amp;value) + sizeof(double));&#10;        node.chunks = create_chunks(raw_data);&#10;&#10;        return node;&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_bytes(PyObject *obj) {&#10;        SerializedNode node;&#10;        node.type = NodeType::BYTES;&#10;        node.meta.type_name = &quot;bytes&quot;;&#10;        node.meta.refcount = 1;&#10;&#10;        // Support multiple bytes-like objects: bytes, bytearray, memoryview, and&#10;        // any object that supports the buffer protocol. We copy the buffer&#10;        // contents into a local vector so it's safe to chunk and transport.&#10;        std::vector&lt;uint8_t&gt; raw_data;&#10;&#10;        // bytes&#10;        if (PyBytes_Check(obj)) {&#10;            char *data = nullptr;&#10;            Py_ssize_t size = 0;&#10;            if (PyBytes_AsStringAndSize(obj, &amp;data, &amp;size) != 0) {&#10;                PyErr_SetString(PyExc_TypeError, &quot;Failed to get bytes data&quot;);&#10;                return node;&#10;            }&#10;            raw_data.assign(reinterpret_cast&lt;uint8_t *&gt;(data), reinterpret_cast&lt;uint8_t *&gt;(data) + size);&#10;            node.meta.type_name = &quot;bytes&quot;;&#10;        }&#10;        // bytearray&#10;        else if (PyByteArray_Check(obj)) {&#10;            char *data = PyByteArray_AsString(obj);&#10;            Py_ssize_t size = PyByteArray_Size(obj);&#10;            raw_data.assign(reinterpret_cast&lt;uint8_t *&gt;(data), reinterpret_cast&lt;uint8_t *&gt;(data) + size);&#10;            node.meta.type_name = &quot;bytearray&quot;;&#10;        }&#10;        // memoryview or other buffer-supporting objects&#10;        else if (PyMemoryView_Check(obj) || PyObject_CheckBuffer(obj)) {&#10;            Py_buffer view;&#10;            // Request a readonly contiguous buffer view for simplicity&#10;            if (PyObject_GetBuffer(obj, &amp;view, PyBUF_CONTIG_RO) != 0) {&#10;                PyErr_SetString(PyExc_TypeError, &quot;Failed to get buffer from object&quot;);&#10;                return node;&#10;            }&#10;            raw_data.assign(reinterpret_cast&lt;uint8_t *&gt;(view.buf), reinterpret_cast&lt;uint8_t *&gt;(view.buf) + view.len);&#10;            if (PyMemoryView_Check(obj)) {&#10;                node.meta.type_name = &quot;memoryview&quot;;&#10;            } else {&#10;                node.meta.type_name = &quot;buffer&quot;;&#10;            }&#10;            PyBuffer_Release(&amp;view);&#10;        } else {&#10;            PyErr_SetString(PyExc_TypeError, &quot;Expected a bytes-like object&quot;);&#10;            return node;&#10;        }&#10;&#10;        node.chunks = create_chunks(raw_data);&#10;&#10;        return node;&#10;    }&#10;&#10;&#10;    SerializedNode PyObjectSerializer::serialize_dict(&#10;        PyObject *obj,&#10;        SerializedGraph &amp;graph,&#10;        std::unordered_map&lt;PyObject *, uint32_t&gt; &amp;visited,&#10;        int depth,&#10;        uint32_t owner_node_id&#10;    ) {&#10;        SerializedNode node;&#10;        node.type = NodeType::DICT;&#10;        node.meta.type_name = &quot;dict&quot;;&#10;        node.meta.refcount = 1;&#10;        node.meta.has_dict = true;&#10;        PyObject *key, *value;&#10;        Py_ssize_t pos = 0;&#10;        while (PyDict_Next(obj, &amp;pos, &amp;key, &amp;value)) {&#10;            // Key&#10;            uint32_t key_id = serialize_recursive(key, graph, visited, depth + 1);&#10;            if (key_id == UINT32_MAX) return node;&#10;            // Value&#10;            uint32_t value_id = serialize_recursive(value, graph, visited, depth + 1);&#10;            if (value_id == UINT32_MAX) return node;&#10;            PyObject *key_str = PyObject_Str(key);&#10;            const char *key_cstr = PyUnicode_AsUTF8(key_str);&#10;            std::string key_name(key_cstr);&#10;            Py_DECREF(key_str);&#10;            node.meta.attr_names.push_back(key_name);&#10;            node.meta.attr_node_ids[key_name] = value_id;&#10;            PointerInfo ptr_key, ptr_val;&#10;            ptr_key.from_node_id = owner_node_id;&#10;            ptr_key.from_chunk_id = 0;&#10;            ptr_key.offset = 0;&#10;            ptr_key.to_node_id = key_id;&#10;            ptr_key.field_name = &quot;key:&quot; + key_name;&#10;            ptr_val.from_node_id = owner_node_id;&#10;            ptr_val.from_chunk_id = 0;&#10;            ptr_val.offset = 0;&#10;            ptr_val.to_node_id = value_id;&#10;            ptr_val.field_name = &quot;val:&quot; + key_name;&#10;            node.pointers.push_back(ptr_key);&#10;            node.pointers.push_back(ptr_val);&#10;            graph.all_pointers.push_back(ptr_key);&#10;            graph.all_pointers.push_back(ptr_val);&#10;        }&#10;        return node;&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_function(&#10;        PyObject *obj,&#10;        SerializedGraph &amp;graph,&#10;        std::unordered_map&lt;PyObject *, uint32_t&gt; &amp;visited,&#10;        int depth,&#10;        uint32_t owner_node_id&#10;    ) {&#10;        SerializedNode node;&#10;        node.type = NodeType::FUNCTION;&#10;        node.meta.type_name = &quot;function&quot;;&#10;        node.meta.refcount = 1;&#10;        PyObject *name = PyObject_GetAttrString(obj, &quot;__name__&quot;);&#10;        if (name) {&#10;            node.meta.module_name = PyUnicode_AsUTF8(name);&#10;            Py_DECREF(name);&#10;        }&#10;        PyObject *code_obj = PyObject_GetAttrString(obj, &quot;__code__&quot;);&#10;        if (code_obj) {&#10;            PyObject *code_bytes = PyObject_GetAttrString(code_obj, &quot;co_code&quot;);&#10;            PyObject *consts = PyObject_GetAttrString(code_obj, &quot;co_consts&quot;);&#10;            PyObject *names = PyObject_GetAttrString(code_obj, &quot;co_names&quot;);&#10;            PyObject *varnames = PyObject_GetAttrString(code_obj, &quot;co_varnames&quot;);&#10;            PyObject *filename = PyObject_GetAttrString(code_obj, &quot;co_filename&quot;);&#10;            PyObject *name_co = PyObject_GetAttrString(code_obj, &quot;co_name&quot;);&#10;            PyObject *lnotab = PyObject_GetAttrString(code_obj, &quot;co_lnotab&quot;);&#10;            PyObject *freevars = PyObject_GetAttrString(code_obj, &quot;co_freevars&quot;);&#10;            PyObject *cellvars = PyObject_GetAttrString(code_obj, &quot;co_cellvars&quot;);&#10;            PyObject *argcount = PyObject_GetAttrString(code_obj, &quot;co_argcount&quot;);&#10;            PyObject *posonlyargcount = PyObject_GetAttrString(code_obj, &quot;co_posonlyargcount&quot;);&#10;            PyObject *kwonlyargcount = PyObject_GetAttrString(code_obj, &quot;co_kwonlyargcount&quot;);&#10;            PyObject *nlocals = PyObject_GetAttrString(code_obj, &quot;co_nlocals&quot;);&#10;            PyObject *stacksize = PyObject_GetAttrString(code_obj, &quot;co_stacksize&quot;);&#10;            PyObject *flags = PyObject_GetAttrString(code_obj, &quot;co_flags&quot;);&#10;            PyObject *firstlineno = PyObject_GetAttrString(code_obj, &quot;co_firstlineno&quot;);&#10;            PyObject *qualname = PyObject_GetAttrString(obj, &quot;__qualname__&quot;);&#10;            if (code_bytes &amp;&amp; PyBytes_Check(code_bytes)) {&#10;                Py_ssize_t size = PyBytes_Size(code_bytes);&#10;                json j_data{};&#10;                const char *data = PyBytes_AsString(code_bytes);&#10;                //                auto j_consts = serialize(consts);&#10;                //                auto j_names = serialize(names);&#10;                //                auto j_varnames = serialize(varnames);&#10;                //                auto j_filename = serialize(filename);&#10;                //                auto j_name_co = serialize(name_co);&#10;                //                auto j_lnotab = serialize(lnotab);&#10;                //                auto j_freevars = serialize(freevars);&#10;                //                auto j_cellvars = serialize(cellvars);&#10;                //                auto j_argcount = (argcount &amp;&amp; PyLong_Check(argcount)) ? PyLong_AsLongLong(argcount) : 0;&#10;                //                auto j_posonlyargcount = (posonlyargcount &amp;&amp; PyLong_Check(posonlyargcount)) ? PyLong_AsLongLong(posonlyargcount) : 0;&#10;                //                auto j_kwonlyargcount = (kwonlyargcount &amp;&amp; PyLong_Check(kwonlyargcount)) ? PyLong_AsLongLong(kwonlyargcount) : 0;&#10;                //                auto j_nlocals = (nlocals &amp;&amp; PyLong_Check(nlocals)) ? PyLong_AsLongLong(nlocals) : 0;&#10;                //                auto j_stacksize = (stacksize &amp;&amp; PyLong_Check(stacksize)) ? PyLong_AsLongLong(stacksize) : 0;&#10;                //                auto j_flags = (flags &amp;&amp; PyLong_Check(flags)) ? PyLong_AsLongLong(flags) : 0;&#10;                //                auto j_firstlineno = (firstlineno &amp;&amp; PyLong_Check(firstlineno)) ? PyLong_AsLongLong(firstlineno) : 0;&#10;                //                auto j_qualname = serialize(qualname);&#10;                //                // Code bytes may contain arbitrary binary data (not valid UTF-8).&#10;                //                // Encode the raw bytes as base64 so the JSON string is valid.&#10;                //                std::vector&lt;uint8_t&gt; code_bytes_vec(reinterpret_cast&lt;const uint8_t *&gt;(data),&#10;                //                                                    reinterpret_cast&lt;const uint8_t *&gt;(data) + size);&#10;                //                j_data[&quot;data&quot;] = base64::encode(code_bytes_vec);&#10;                //                // SerializedGraph::to_bytes() returns binary data; base64-encode&#10;                //                // to ensure the JSON fields are valid UTF-8 strings.&#10;                //                std::string consts_b64 = base64::encode(j_consts.to_bytes());&#10;                //                std::string names_b64 = base64::encode(j_names.to_bytes());&#10;                //                std::string varnames_b64 = base64::encode(j_varnames.to_bytes());&#10;                //                std::string filename_b64 = base64::encode(j_filename.to_bytes());&#10;                //                std::string name_b64 = base64::encode(j_name_co.to_bytes());&#10;                //                std::string lnotab_b64 = base64::encode(j_lnotab.to_bytes());&#10;                //                std::string freevars_b64 = base64::encode(j_freevars.to_bytes());&#10;                //                std::string cellvars_b64 = base64::encode(j_cellvars.to_bytes());&#10;                //                std::string qualname_b64 = base64::encode(j_qualname.to_bytes());&#10;                //&#10;                //                // Diagnostic logging to stderr to help debug invalid UTF-8 during JSON dump&#10;                //                fprintf(stderr, &quot;pyser: func code bytes=%zu consts_b64_len=%zu names_b64_len=%zu varnames_b64_len=%zu filename_b64_len=%zu name_b64_len=%zu lnotab_b64_len=%zu qualname_b64_len=%zu\n&quot;,&#10;                //                        code_bytes_vec.size(), consts_b64.size(), names_b64.size(), varnames_b64.size(), filename_b64.size(), name_b64.size(), lnotab_b64.size(), qualname_b64.size());&#10;                //                if (!consts_b64.empty()) fprintf(stderr, &quot;pyser: consts_b64_prefix=%c%c%c\n&quot;, consts_b64[0], consts_b64[1], consts_b64[2]);&#10;                //&#10;                //                j_data[&quot;consts&quot;] = consts_b64;&#10;                //                j_data[&quot;names&quot;] = names_b64;&#10;                //                j_data[&quot;varnames&quot;] = varnames_b64;&#10;                //                j_data[&quot;filename&quot;] = filename_b64;&#10;                //                j_data[&quot;name&quot;] = name_b64;&#10;                //                j_data[&quot;lnotab&quot;] = lnotab_b64;&#10;                //                j_data[&quot;freevars&quot;] = freevars_b64;&#10;                //                j_data[&quot;cellvars&quot;] = cellvars_b64;&#10;                //                j_data[&quot;argcount&quot;] = j_argcount;&#10;                //                j_data[&quot;posonlyargcount&quot;] = j_posonlyargcount;&#10;                //                j_data[&quot;kwonlyargcount&quot;] = j_kwonlyargcount;&#10;                //                j_data[&quot;nlocals&quot;] = j_nlocals;&#10;                //                j_data[&quot;stacksize&quot;] = j_stacksize;&#10;                //                j_data[&quot;flags&quot;] = j_flags;&#10;                //                j_data[&quot;firstlineno&quot;] = j_firstlineno;&#10;                //                j_data[&quot;qualname&quot;] = base64::encode(j_qualname.to_bytes());&#10;                //                std::string dump_str;&#10;                //                try {&#10;                //                    dump_str = j_data.dump();&#10;                //                } catch (const nlohmann::json::exception &amp;ex) {&#10;                //                    fprintf(stderr, &quot;pyser: j_data.dump() failed: %s\n&quot;, ex.what());&#10;                //                    fprintf(stderr, &quot;pyser: j_data keys and sizes:\n&quot;);&#10;                //                    if (j_data.contains(&quot;data&quot;)) fprintf(stderr, &quot; data_len=%zu\n&quot;, j_data[&quot;data&quot;].get&lt;std::string&gt;().size());&#10;                //                    if (j_data.contains(&quot;consts&quot;)) fprintf(stderr, &quot; consts_len=%zu\n&quot;, j_data[&quot;consts&quot;].get&lt;std::string&gt;().size());&#10;                //                    if (j_data.contains(&quot;names&quot;)) fprintf(stderr, &quot; names_len=%zu\n&quot;, j_data[&quot;names&quot;].get&lt;std::string&gt;().size());&#10;                //                    if (j_data.contains(&quot;varnames&quot;)) fprintf(stderr, &quot; varnames_len=%zu\n&quot;, j_data[&quot;varnames&quot;].get&lt;std::string&gt;().size());&#10;                //                    if (j_data.contains(&quot;filename&quot;)) fprintf(stderr, &quot; filename_len=%zu\n&quot;, j_data[&quot;filename&quot;].get&lt;std::string&gt;().size());&#10;                //                    if (j_data.contains(&quot;name&quot;)) fprintf(stderr, &quot; name_len=%zu\n&quot;, j_data[&quot;name&quot;].get&lt;std::string&gt;().size());&#10;                //                    if (j_data.contains(&quot;lnotab&quot;)) fprintf(stderr, &quot; lnotab_len=%zu\n&quot;, j_data[&quot;lnotab&quot;].get&lt;std::string&gt;().size());&#10;                //                    if (j_data.contains(&quot;qualname&quot;)) fprintf(stderr, &quot; qualname_len=%zu\n&quot;, j_data[&quot;qualname&quot;].get&lt;std::string&gt;().size());&#10;                //                    throw;&#10;                //                }&#10;                //                node.meta.func_code = base64::encode(&#10;                //                    std::vector&lt;uint8_t&gt;(dump_str.begin(), dump_str.end())&#10;                //                );&#10;                // Use Python's marshal.dumps(code_obj) to obtain a bytes blob.&#10;                // We call it via the Python C-API (import marshal and call dumps).&#10;                node.meta.func_code.clear();&#10;                PyObject *marshal_mod = PyImport_ImportModule(&quot;marshal&quot;);&#10;                if (marshal_mod) {&#10;                    PyObject *dumps = PyObject_GetAttrString(marshal_mod, &quot;dumps&quot;);&#10;                    if (dumps &amp;&amp; PyCallable_Check(dumps)) {&#10;                        PyObject *marshalled = PyObject_CallFunctionObjArgs(dumps, code_obj, nullptr);&#10;                        if (marshalled) {&#10;                            if (PyBytes_Check(marshalled)) {&#10;                                char *mdata = PyBytes_AsString(marshalled);&#10;                                Py_ssize_t mlen = PyBytes_Size(marshalled);&#10;                                std::vector&lt;uint8_t&gt; marsh_vec;&#10;                                marsh_vec.assign(reinterpret_cast&lt;unsigned char *&gt;(mdata), reinterpret_cast&lt;unsigned char *&gt;(mdata) + mlen);&#10;                                node.meta.func_code = base64::encode(marsh_vec);&#10;                            }&#10;                            Py_DECREF(marshalled);&#10;                        }&#10;                    }&#10;                    Py_XDECREF(dumps);&#10;                    Py_DECREF(marshal_mod);&#10;                }&#10;                 // DECREF attribute objects we created&#10;                 Py_XDECREF(argcount);&#10;                 Py_XDECREF(posonlyargcount);&#10;                 Py_XDECREF(kwonlyargcount);&#10;                 Py_XDECREF(nlocals);&#10;                 Py_XDECREF(stacksize);&#10;                 Py_XDECREF(flags);&#10;                 Py_XDECREF(firstlineno);&#10;                 Py_XDECREF(qualname);&#10;            }&#10;            Py_XDECREF(code_bytes);&#10;            Py_XDECREF(consts);&#10;            Py_XDECREF(names);&#10;            Py_XDECREF(varnames);&#10;            Py_XDECREF(filename);&#10;            Py_XDECREF(name_co);&#10;            Py_XDECREF(lnotab);&#10;            Py_XDECREF(freevars);&#10;            Py_XDECREF(cellvars);&#10;            Py_XDECREF(code_obj);&#10;        }&#10;        PyObject *closure = PyObject_GetAttrString(obj, &quot;__closure__&quot;);&#10;        if (closure &amp;&amp; closure != Py_None) {&#10;            Py_ssize_t n_cells = PyTuple_Size(closure);&#10;            for (Py_ssize_t i = 0; i &lt; n_cells; i++) {&#10;                PyObject *cell = PyTuple_GetItem(closure, i);&#10;                if (PyObject *cell_contents = PyObject_GetAttrString(cell, &quot;cell_contents&quot;)) {&#10;                    uint32_t cell_id = serialize_recursive(&#10;                        cell_contents, graph, visited, depth + 1&#10;                    );&#10;                    PointerInfo ptr;&#10;                    ptr.from_node_id = owner_node_id;&#10;                    ptr.from_chunk_id = 0;&#10;                    ptr.offset = 0;&#10;                    ptr.to_node_id = cell_id;&#10;                    ptr.field_name = &quot;closure:&quot; + std::to_string(i);&#10;                    node.pointers.push_back(ptr);&#10;                    graph.all_pointers.push_back(ptr);&#10;                    Py_DECREF(cell_contents);&#10;                }&#10;            }&#10;        }&#10;        Py_XDECREF(closure);&#10;        return node;&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_module(PyObject *obj) {&#10;        SerializedNode node;&#10;        node.type = NodeType::MODULE;&#10;        node.meta.type_name = &quot;module&quot;;&#10;        node.meta.refcount = 1;&#10;        node.meta.total_size = 0;&#10;        node.meta.has_dict = false;&#10;        PyObject *name = PyObject_GetAttrString(obj, &quot;__name__&quot;);&#10;        if (name) {&#10;            node.meta.module_name = PyUnicode_AsUTF8(name);&#10;            Py_DECREF(name);&#10;        }&#10;        return node;&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_custom(&#10;        PyObject *obj,&#10;        SerializedGraph &amp;graph,&#10;        std::unordered_map&lt;PyObject *, uint32_t&gt; &amp;visited,&#10;        int depth,&#10;        uint32_t owner_node_id&#10;    ) {&#10;        SerializedNode node;&#10;        node.type = NodeType::CUSTOM;&#10;        node.meta.refcount = 1;&#10;        PyTypeObject *type = Py_TYPE(obj);&#10;        node.meta.type_name = type-&gt;tp_name;&#10;        PyObject *module = PyObject_GetAttrString(reinterpret_cast&lt;PyObject *&gt;(type), &quot;__module__&quot;);&#10;        if (module &amp;&amp; PyUnicode_Check(module)) {&#10;            node.meta.module_name = PyUnicode_AsUTF8(module);&#10;        }&#10;        node.meta.total_size = 0;&#10;        node.meta.has_dict = false;&#10;        Py_XDECREF(module);&#10;        if (PyObject_HasAttrString(obj, &quot;__dict__&quot;)) {&#10;            PyObject *dict = PyObject_GetAttrString(obj, &quot;__dict__&quot;);&#10;            if (dict &amp;&amp; PyDict_Check(dict)) {&#10;                node.meta.has_dict = true;&#10;                PyObject *key, *value;&#10;                Py_ssize_t pos = 0;&#10;                while (PyDict_Next(dict, &amp;pos, &amp;key, &amp;value)) {&#10;                    if (!PyUnicode_Check(key)) continue;&#10;                    const char *attr_name = PyUnicode_AsUTF8(key);&#10;                    uint32_t value_id = serialize_recursive(value, graph, visited, depth + 1);&#10;                    if (value_id != UINT32_MAX) {&#10;                        node.meta.attr_names.emplace_back(attr_name);&#10;                        node.meta.attr_node_ids[attr_name] = value_id;&#10;                        PointerInfo ptr;&#10;                        ptr.from_node_id = owner_node_id;&#10;                        ptr.from_chunk_id = 0;&#10;                        ptr.offset = 0;&#10;                        ptr.to_node_id = value_id;&#10;                        ptr.field_name = attr_name;&#10;                        node.pointers.push_back(ptr);&#10;                        graph.all_pointers.push_back(ptr);&#10;                    }&#10;                }&#10;            }&#10;            Py_XDECREF(dict);&#10;        }&#10;        return node;&#10;    }&#10;&#10;    SerializedGraph PyObjectSerializer::serialize(PyObject *obj) {&#10;        SerializedGraph graph;&#10;        std::unordered_map&lt;PyObject *, uint32_t&gt; visited;&#10;        graph.root_id = serialize_recursive(obj, graph, visited, 0);&#10;        if (graph.root_id == UINT32_MAX) {&#10;            throw std::runtime_error(&quot;Serialization failed&quot;);&#10;        }&#10;        return graph;&#10;    }&#10;&#10;    uint32_t PyObjectSerializer::serialize_recursive(&#10;        PyObject *obj,&#10;        SerializedGraph &amp;graph,&#10;        std::unordered_map&lt;PyObject *, uint32_t&gt; &amp;visited,&#10;        int depth&#10;    ) {&#10;        if (depth &gt; MAX_DEPTH) {&#10;            PyErr_SetString(PyExc_ValueError, &quot;Object nesting too deep&quot;);&#10;            return UINT32_MAX;&#10;        }&#10;        auto it = visited.find(obj);&#10;        if (it != visited.end()) {&#10;            SerializedNode ref_node;&#10;            ref_node.node_id = next_node_id_++;&#10;            ref_node.type = NodeType::REFERENCE;&#10;            ref_node.meta.refcount = 0;&#10;            uint32_t ref_target = it-&gt;second;&#10;            std::vector&lt;uint8_t&gt; ref_data(sizeof(uint32_t));&#10;            std::memcpy(ref_data.data(), &amp;ref_target, sizeof(uint32_t));&#10;            ref_node.chunks = create_chunks(ref_data);&#10;            graph.nodes.push_back(ref_node);&#10;            return ref_node.node_id;&#10;        }&#10;        uint32_t current_id = next_node_id_++;&#10;        visited[obj] = current_id;&#10;        SerializedNode node;&#10;        // Assign the canonical node id immediately so any pointers created by&#10;        // per-type serializers use the correct from_node_id.&#10;        node.node_id = current_id;&#10;        if (obj == Py_None) {&#10;            node.type = NodeType::NONE;&#10;            node.meta.refcount = 1;&#10;        } else if (PyBool_Check(obj)) {&#10;            node.type = NodeType::BOOL;&#10;            node.meta.refcount = 1;&#10;            uint8_t val = (obj == Py_True) ? 1 : 0;&#10;            node.chunks = create_chunks({val});&#10;        } else if (PyLong_Check(obj)) {&#10;            node = serialize_int(obj);&#10;            node.node_id = current_id;&#10;        } else if (PyFloat_Check(obj)) {&#10;            node = serialize_float(obj);&#10;            node.node_id = current_id;&#10;        } else if (PyUnicode_Check(obj)) {&#10;            node = serialize_string(obj);&#10;            node.node_id = current_id;&#10;        } else if (PyBytes_Check(obj)) {&#10;            node = serialize_bytes(obj);&#10;            node.node_id = current_id;&#10;        } else if (PyList_Check(obj)) {&#10;            node = serialize_container(obj, NodeType::LIST, graph, visited, depth, current_id);&#10;            node.node_id = current_id;&#10;        } else if (PyTuple_Check(obj)) {&#10;            node = serialize_container(obj, NodeType::TUPLE, graph, visited, depth, current_id);&#10;            node.node_id = current_id;&#10;        } else if (PyDict_Check(obj)) {&#10;            node = serialize_dict(obj, graph, visited, depth, current_id);&#10;            node.node_id = current_id;&#10;        } else if (PySet_Check(obj)) {&#10;            node = serialize_container(obj, NodeType::SET, graph, visited, depth, current_id);&#10;            node.node_id = current_id;&#10;        } else if (PyFunction_Check(obj)) {&#10;            node = serialize_function(obj, graph, visited, depth, current_id);&#10;            node.node_id = current_id;&#10;        } else if (PyModule_Check(obj)) {&#10;            node = serialize_module(obj);&#10;            node.node_id = current_id;&#10;        } else if (PyObject_HasAttrString(obj, &quot;fileno&quot;)) {&#10;            PyErr_SetString(PyExc_TypeError,&#10;                            &quot;Cannot serialize file objects. Extract file descriptor manually.&quot;);&#10;            return UINT32_MAX;&#10;        } else {&#10;            node = serialize_custom(obj, graph, visited, depth, current_id);&#10;            node.node_id = current_id;&#10;        }&#10;        // node.node_id was set earlier to current_id; push the finalized node.&#10;        graph.nodes.push_back(node);&#10;        return current_id;&#10;    }&#10;} // namespace pyser&#10;" />
              <option name="updatedContent" value="// pyser.cpp&#10;#include &quot;pyser.hpp&quot;&#10;#include &lt;openssl/sha.h&gt;&#10;#include &lt;nlohmann/json.hpp&gt;&#10;#include &lt;cppcodec/base64_rfc4648.hpp&gt;&#10;#include &lt;Python.h&gt;&#10;&#10;namespace pyser {&#10;    using json = nlohmann::json;&#10;    using base64 = cppcodec::base64_rfc4648;&#10;&#10;&#10;    std::vector&lt;DataChunk&gt; PyObjectSerializer::create_chunks(&#10;        const std::vector&lt;uint8_t&gt; &amp;data&#10;    ) {&#10;        std::vector&lt;DataChunk&gt; chunks;&#10;        size_t offset = 0;&#10;&#10;        while (offset &lt; data.size()) {&#10;            DataChunk chunk;&#10;            chunk.chunk_id = next_chunk_id_++;&#10;            size_t chunk_size = std::min(CHUNK_SIZE, data.size() - offset);&#10;            chunk.raw_data.assign(&#10;                data.begin() + offset,&#10;                data.begin() + offset + chunk_size&#10;            );&#10;            chunk.original_size = chunk_size;&#10;            chunk.base64_data = base64::encode(chunk.raw_data);&#10;            chunk.sha256_hash = compute_sha256(chunk.raw_data);&#10;            chunks.push_back(chunk);&#10;            offset += chunk_size;&#10;        }&#10;&#10;        return chunks;&#10;    }&#10;&#10;    std::string PyObjectSerializer::compute_sha256(const std::vector&lt;uint8_t&gt; &amp;data) {&#10;        unsigned char hash[SHA256_DIGEST_LENGTH];&#10;        SHA256(data.data(), data.size(), hash);&#10;        char hex[SHA256_DIGEST_LENGTH * 2 + 1];&#10;        for (int i = 0; i &lt; SHA256_DIGEST_LENGTH; i++) {&#10;            sprintf(hex + i * 2, &quot;%02x&quot;, hash[i]);&#10;        }&#10;        hex[SHA256_DIGEST_LENGTH * 2] = '\0';&#10;&#10;        return {hex};&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_bigint(PyObject *obj) {&#10;        SerializedNode node;&#10;        node.type = NodeType::INT;&#10;        node.meta.type_name = &quot;int&quot;;&#10;        node.meta.is_bigint = true;&#10;        // Diagnostic: ensure obj is a PyLong&#10;        if (!PyLong_Check(obj)) {&#10;            fprintf(stderr, &quot;pyser: serialize_bigint called with non-long type: %s\n&quot;, Py_TYPE(obj)-&gt;tp_name);&#10;        } else {&#10;            fprintf(stderr, &quot;pyser: serialize_bigint called on PyLong\n&quot;);&#10;        }&#10;        size_t n_bits = _PyLong_NumBits(obj);&#10;        size_t n_bytes = (n_bits + 7) / 8;&#10;        std::vector&lt;uint32_t&gt; digits;&#10;        auto *long_obj = reinterpret_cast&lt;PyLongObject *&gt;(obj);&#10;        std::vector&lt;uint8_t&gt; raw_data(n_bytes);&#10;        _PyLong_AsByteArray(long_obj, raw_data.data(), n_bytes, 1, 1, 1);&#10;        node.meta.bigint_num_digits = n_bytes;&#10;        node.chunks = create_chunks(raw_data);&#10;        return node;&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_int(PyObject *obj) {&#10;        SerializedNode node;&#10;        node.type = NodeType::INT;&#10;        node.meta.type_name = &quot;int&quot;;&#10;        node.meta.refcount = 1;&#10;        // Diagnostic: print incoming type info&#10;        if (obj) fprintf(stderr, &quot;pyser: serialize_int called on type: %s\n&quot;, Py_TYPE(obj)-&gt;tp_name);&#10;        int overflow;&#10;        long long value = PyLong_AsLongLongAndOverflow(obj, &amp;overflow);&#10;        if (overflow != 0) {&#10;            return serialize_bigint(obj);&#10;        }&#10;        node.meta.is_bigint = false;&#10;        std::vector&lt;uint8_t&gt; raw_data(sizeof(long long));&#10;        std::memcpy(raw_data.data(), &amp;value, sizeof(long long));&#10;        node.chunks = create_chunks(raw_data);&#10;        return node;&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_string(PyObject *obj) {&#10;        SerializedNode node;&#10;        node.type = NodeType::STRING;&#10;        node.meta.type_name = &quot;str&quot;;&#10;        node.meta.refcount = 1;&#10;        node.meta.has_dict = false;&#10;        Py_ssize_t size;&#10;        const char *data = PyUnicode_AsUTF8AndSize(obj, &amp;size);&#10;        std::vector&lt;uint8_t&gt; raw_data(data, data + size);&#10;        node.meta.total_size = size;&#10;        node.chunks = create_chunks(raw_data);&#10;        return node;&#10;    }&#10;&#10;    // Update signatures to accept owner node id for pointer population&#10;    SerializedNode PyObjectSerializer::serialize_container(&#10;        PyObject *obj,&#10;        NodeType type,&#10;        SerializedGraph &amp;graph,&#10;        std::unordered_map&lt;PyObject *, uint32_t&gt; &amp;visited,&#10;        int depth,&#10;        uint32_t owner_node_id&#10;    ) {&#10;        SerializedNode node;&#10;        node.type = type;&#10;        node.meta.refcount = 1;&#10;        Py_ssize_t size;&#10;        if (type == NodeType::LIST) {&#10;            size = PyList_Size(obj);&#10;            node.meta.type_name = &quot;list&quot;;&#10;        } else if (type == NodeType::TUPLE) {&#10;            size = PyTuple_Size(obj);&#10;            node.meta.type_name = &quot;tuple&quot;;&#10;        } else if (type == NodeType::SET) {&#10;            size = PySet_Size(obj);&#10;            node.meta.type_name = &quot;set&quot;;&#10;        } else {&#10;            PyErr_SetString(PyExc_TypeError, &quot;Unsupported container type&quot;);&#10;            node.meta.has_dict = false;&#10;            node.meta.total_size = 0;&#10;            return node;&#10;        }&#10;        node.meta.has_dict = false;&#10;        node.meta.total_size = size;&#10;        for (Py_ssize_t i = 0; i &lt; size; i++) {&#10;            PyObject *item = nullptr;&#10;            if (type == NodeType::LIST) {&#10;                item = PyList_GetItem(obj, i);&#10;            } else if (type == NodeType::TUPLE) {&#10;                item = PyTuple_GetItem(obj, i);&#10;            } else {&#10;                PyObject *iter = PyObject_GetIter(obj);&#10;                for (Py_ssize_t j = 0; j &lt;= i; j++) {&#10;                    item = PyIter_Next(iter);&#10;                }&#10;                Py_DECREF(iter);&#10;            }&#10;            if (!item) continue;&#10;            uint32_t child_id = serialize_recursive(item, graph, visited, depth + 1);&#10;            if (child_id == UINT32_MAX) {&#10;                return node;&#10;            }&#10;            PointerInfo ptr;&#10;            ptr.from_node_id = owner_node_id;&#10;            ptr.from_chunk_id = 0;&#10;            ptr.offset = i * sizeof(void *);&#10;            ptr.to_node_id = child_id;&#10;            ptr.field_name = std::to_string(i);&#10;            node.pointers.push_back(ptr);&#10;            graph.all_pointers.push_back(ptr);&#10;        }&#10;        return node;&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_float(PyObject *obj) {&#10;        SerializedNode node;&#10;        node.type = NodeType::FLOAT;&#10;        node.meta.type_name = &quot;float&quot;;&#10;        node.meta.refcount = 1;&#10;&#10;        if (!PyFloat_Check(obj)) {&#10;            PyErr_SetString(PyExc_TypeError, &quot;Expected a float object&quot;);&#10;            return node;&#10;        }&#10;&#10;        double value = PyFloat_AsDouble(obj);&#10;        std::vector raw_data(reinterpret_cast&lt;uint8_t *&gt;(&amp;value),&#10;                             reinterpret_cast&lt;uint8_t *&gt;(&amp;value) + sizeof(double));&#10;        node.chunks = create_chunks(raw_data);&#10;&#10;        return node;&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_bytes(PyObject *obj) {&#10;        SerializedNode node;&#10;        node.type = NodeType::BYTES;&#10;        node.meta.type_name = &quot;bytes&quot;;&#10;        node.meta.refcount = 1;&#10;&#10;        // Support multiple bytes-like objects: bytes, bytearray, memoryview, and&#10;        // any object that supports the buffer protocol. We copy the buffer&#10;        // contents into a local vector so it's safe to chunk and transport.&#10;        std::vector&lt;uint8_t&gt; raw_data;&#10;&#10;        // bytes&#10;        if (PyBytes_Check(obj)) {&#10;            char *data = nullptr;&#10;            Py_ssize_t size = 0;&#10;            if (PyBytes_AsStringAndSize(obj, &amp;data, &amp;size) != 0) {&#10;                PyErr_SetString(PyExc_TypeError, &quot;Failed to get bytes data&quot;);&#10;                return node;&#10;            }&#10;            raw_data.assign(reinterpret_cast&lt;uint8_t *&gt;(data), reinterpret_cast&lt;uint8_t *&gt;(data) + size);&#10;            node.meta.type_name = &quot;bytes&quot;;&#10;        }&#10;        // bytearray&#10;        else if (PyByteArray_Check(obj)) {&#10;            char *data = PyByteArray_AsString(obj);&#10;            Py_ssize_t size = PyByteArray_Size(obj);&#10;            raw_data.assign(reinterpret_cast&lt;uint8_t *&gt;(data), reinterpret_cast&lt;uint8_t *&gt;(data) + size);&#10;            node.meta.type_name = &quot;bytearray&quot;;&#10;        }&#10;        // memoryview or other buffer-supporting objects&#10;        else if (PyMemoryView_Check(obj) || PyObject_CheckBuffer(obj)) {&#10;            Py_buffer view;&#10;            // Request a readonly contiguous buffer view for simplicity&#10;            if (PyObject_GetBuffer(obj, &amp;view, PyBUF_CONTIG_RO) != 0) {&#10;                PyErr_SetString(PyExc_TypeError, &quot;Failed to get buffer from object&quot;);&#10;                return node;&#10;            }&#10;            raw_data.assign(reinterpret_cast&lt;uint8_t *&gt;(view.buf), reinterpret_cast&lt;uint8_t *&gt;(view.buf) + view.len);&#10;            if (PyMemoryView_Check(obj)) {&#10;                node.meta.type_name = &quot;memoryview&quot;;&#10;            } else {&#10;                node.meta.type_name = &quot;buffer&quot;;&#10;            }&#10;            PyBuffer_Release(&amp;view);&#10;        } else {&#10;            PyErr_SetString(PyExc_TypeError, &quot;Expected a bytes-like object&quot;);&#10;            return node;&#10;        }&#10;&#10;        node.chunks = create_chunks(raw_data);&#10;&#10;        return node;&#10;    }&#10;&#10;&#10;    SerializedNode PyObjectSerializer::serialize_dict(&#10;        PyObject *obj,&#10;        SerializedGraph &amp;graph,&#10;        std::unordered_map&lt;PyObject *, uint32_t&gt; &amp;visited,&#10;        int depth,&#10;        uint32_t owner_node_id&#10;    ) {&#10;        SerializedNode node;&#10;        node.type = NodeType::DICT;&#10;        node.meta.type_name = &quot;dict&quot;;&#10;        node.meta.refcount = 1;&#10;        node.meta.has_dict = true;&#10;        PyObject *key, *value;&#10;        Py_ssize_t pos = 0;&#10;        while (PyDict_Next(obj, &amp;pos, &amp;key, &amp;value)) {&#10;            // Key&#10;            uint32_t key_id = serialize_recursive(key, graph, visited, depth + 1);&#10;            if (key_id == UINT32_MAX) return node;&#10;            // Value&#10;            uint32_t value_id = serialize_recursive(value, graph, visited, depth + 1);&#10;            if (value_id == UINT32_MAX) return node;&#10;            PyObject *key_str = PyObject_Str(key);&#10;            const char *key_cstr = PyUnicode_AsUTF8(key_str);&#10;            std::string key_name(key_cstr);&#10;            Py_DECREF(key_str);&#10;            node.meta.attr_names.push_back(key_name);&#10;            node.meta.attr_node_ids[key_name] = value_id;&#10;            PointerInfo ptr_key, ptr_val;&#10;            ptr_key.from_node_id = owner_node_id;&#10;            ptr_key.from_chunk_id = 0;&#10;            ptr_key.offset = 0;&#10;            ptr_key.to_node_id = key_id;&#10;            ptr_key.field_name = &quot;key:&quot; + key_name;&#10;            ptr_val.from_node_id = owner_node_id;&#10;            ptr_val.from_chunk_id = 0;&#10;            ptr_val.offset = 0;&#10;            ptr_val.to_node_id = value_id;&#10;            ptr_val.field_name = &quot;val:&quot; + key_name;&#10;            node.pointers.push_back(ptr_key);&#10;            node.pointers.push_back(ptr_val);&#10;            graph.all_pointers.push_back(ptr_key);&#10;            graph.all_pointers.push_back(ptr_val);&#10;        }&#10;        return node;&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_function(&#10;        PyObject *obj,&#10;        SerializedGraph &amp;graph,&#10;        std::unordered_map&lt;PyObject *, uint32_t&gt; &amp;visited,&#10;        int depth,&#10;        uint32_t owner_node_id&#10;    ) {&#10;        SerializedNode node;&#10;        node.type = NodeType::FUNCTION;&#10;        node.meta.type_name = &quot;function&quot;;&#10;        node.meta.refcount = 1;&#10;        PyObject *name = PyObject_GetAttrString(obj, &quot;__name__&quot;);&#10;        if (name) {&#10;            node.meta.module_name = PyUnicode_AsUTF8(name);&#10;            Py_DECREF(name);&#10;        }&#10;        PyObject *code_obj = PyObject_GetAttrString(obj, &quot;__code__&quot;);&#10;        if (code_obj) {&#10;            PyObject *code_bytes = PyObject_GetAttrString(code_obj, &quot;co_code&quot;);&#10;            PyObject *consts = PyObject_GetAttrString(code_obj, &quot;co_consts&quot;);&#10;            PyObject *names = PyObject_GetAttrString(code_obj, &quot;co_names&quot;);&#10;            PyObject *varnames = PyObject_GetAttrString(code_obj, &quot;co_varnames&quot;);&#10;            PyObject *filename = PyObject_GetAttrString(code_obj, &quot;co_filename&quot;);&#10;            PyObject *name_co = PyObject_GetAttrString(code_obj, &quot;co_name&quot;);&#10;            PyObject *lnotab = PyObject_GetAttrString(code_obj, &quot;co_lnotab&quot;);&#10;            PyObject *freevars = PyObject_GetAttrString(code_obj, &quot;co_freevars&quot;);&#10;            PyObject *cellvars = PyObject_GetAttrString(code_obj, &quot;co_cellvars&quot;);&#10;            PyObject *argcount = PyObject_GetAttrString(code_obj, &quot;co_argcount&quot;);&#10;            PyObject *posonlyargcount = PyObject_GetAttrString(code_obj, &quot;co_posonlyargcount&quot;);&#10;            PyObject *kwonlyargcount = PyObject_GetAttrString(code_obj, &quot;co_kwonlyargcount&quot;);&#10;            PyObject *nlocals = PyObject_GetAttrString(code_obj, &quot;co_nlocals&quot;);&#10;            PyObject *stacksize = PyObject_GetAttrString(code_obj, &quot;co_stacksize&quot;);&#10;            PyObject *flags = PyObject_GetAttrString(code_obj, &quot;co_flags&quot;);&#10;            PyObject *firstlineno = PyObject_GetAttrString(code_obj, &quot;co_firstlineno&quot;);&#10;            PyObject *qualname = PyObject_GetAttrString(obj, &quot;__qualname__&quot;);&#10;            if (code_bytes &amp;&amp; PyBytes_Check(code_bytes)) {&#10;                Py_ssize_t size = PyBytes_Size(code_bytes);&#10;                json j_data{};&#10;                const char *data = PyBytes_AsString(code_bytes);&#10;                //                auto j_consts = serialize(consts);&#10;                //                auto j_names = serialize(names);&#10;                //                auto j_varnames = serialize(varnames);&#10;                //                auto j_filename = serialize(filename);&#10;                //                auto j_name_co = serialize(name_co);&#10;                //                auto j_lnotab = serialize(lnotab);&#10;                //                auto j_freevars = serialize(freevars);&#10;                //                auto j_cellvars = serialize(cellvars);&#10;                //                auto j_argcount = (argcount &amp;&amp; PyLong_Check(argcount)) ? PyLong_AsLongLong(argcount) : 0;&#10;                //                auto j_posonlyargcount = (posonlyargcount &amp;&amp; PyLong_Check(posonlyargcount)) ? PyLong_AsLongLong(posonlyargcount) : 0;&#10;                //                auto j_kwonlyargcount = (kwonlyargcount &amp;&amp; PyLong_Check(kwonlyargcount)) ? PyLong_AsLongLong(kwonlyargcount) : 0;&#10;                //                auto j_nlocals = (nlocals &amp;&amp; PyLong_Check(nlocals)) ? PyLong_AsLongLong(nlocals) : 0;&#10;                //                auto j_stacksize = (stacksize &amp;&amp; PyLong_Check(stacksize)) ? PyLong_AsLongLong(stacksize) : 0;&#10;                //                auto j_flags = (flags &amp;&amp; PyLong_Check(flags)) ? PyLong_AsLongLong(flags) : 0;&#10;                //                auto j_firstlineno = (firstlineno &amp;&amp; PyLong_Check(firstlineno)) ? PyLong_AsLongLong(firstlineno) : 0;&#10;                //                auto j_qualname = serialize(qualname);&#10;                //                // Code bytes may contain arbitrary binary data (not valid UTF-8).&#10;                //                // Encode the raw bytes as base64 so the JSON string is valid.&#10;                //                std::vector&lt;uint8_t&gt; code_bytes_vec(reinterpret_cast&lt;const uint8_t *&gt;(data),&#10;                //                                                    reinterpret_cast&lt;const uint8_t *&gt;(data) + size);&#10;                //                j_data[&quot;data&quot;] = base64::encode(code_bytes_vec);&#10;                //                // SerializedGraph::to_bytes() returns binary data; base64-encode&#10;                //                // to ensure the JSON fields are valid UTF-8 strings.&#10;                //                std::string consts_b64 = base64::encode(j_consts.to_bytes());&#10;                //                std::string names_b64 = base64::encode(j_names.to_bytes());&#10;                //                std::string varnames_b64 = base64::encode(j_varnames.to_bytes());&#10;                //                std::string filename_b64 = base64::encode(j_filename.to_bytes());&#10;                //                std::string name_b64 = base64::encode(j_name_co.to_bytes());&#10;                //                std::string lnotab_b64 = base64::encode(j_lnotab.to_bytes());&#10;                //                std::string freevars_b64 = base64::encode(j_freevars.to_bytes());&#10;                //                std::string cellvars_b64 = base64::encode(j_cellvars.to_bytes());&#10;                //                std::string qualname_b64 = base64::encode(j_qualname.to_bytes());&#10;                //&#10;                //                // Diagnostic logging to stderr to help debug invalid UTF-8 during JSON dump&#10;                //                fprintf(stderr, &quot;pyser: func code bytes=%zu consts_b64_len=%zu names_b64_len=%zu varnames_b64_len=%zu filename_b64_len=%zu name_b64_len=%zu lnotab_b64_len=%zu qualname_b64_len=%zu\n&quot;,&#10;                //                        code_bytes_vec.size(), consts_b64.size(), names_b64.size(), varnames_b64.size(), filename_b64.size(), name_b64.size(), lnotab_b64.size(), qualname_b64.size());&#10;                //                if (!consts_b64.empty()) fprintf(stderr, &quot;pyser: consts_b64_prefix=%c%c%c\n&quot;, consts_b64[0], consts_b64[1], consts_b64[2]);&#10;                //&#10;                //                j_data[&quot;consts&quot;] = consts_b64;&#10;                //                j_data[&quot;names&quot;] = names_b64;&#10;                //                j_data[&quot;varnames&quot;] = varnames_b64;&#10;                //                j_data[&quot;filename&quot;] = filename_b64;&#10;                //                j_data[&quot;name&quot;] = name_b64;&#10;                //                j_data[&quot;lnotab&quot;] = lnotab_b64;&#10;                //                j_data[&quot;freevars&quot;] = freevars_b64;&#10;                //                j_data[&quot;cellvars&quot;] = cellvars_b64;&#10;                //                j_data[&quot;argcount&quot;] = j_argcount;&#10;                //                j_data[&quot;posonlyargcount&quot;] = j_posonlyargcount;&#10;                //                j_data[&quot;kwonlyargcount&quot;] = j_kwonlyargcount;&#10;                //                j_data[&quot;nlocals&quot;] = j_nlocals;&#10;                //                j_data[&quot;stacksize&quot;] = j_stacksize;&#10;                //                j_data[&quot;flags&quot;] = j_flags;&#10;                //                j_data[&quot;firstlineno&quot;] = j_firstlineno;&#10;                //                j_data[&quot;qualname&quot;] = base64::encode(j_qualname.to_bytes());&#10;                //                std::string dump_str;&#10;                //                try {&#10;                //                    dump_str = j_data.dump();&#10;                //                } catch (const nlohmann::json::exception &amp;ex) {&#10;                //                    fprintf(stderr, &quot;pyser: j_data.dump() failed: %s\n&quot;, ex.what());&#10;                //                    fprintf(stderr, &quot;pyser: j_data keys and sizes:\n&quot;);&#10;                //                    if (j_data.contains(&quot;data&quot;)) fprintf(stderr, &quot; data_len=%zu\n&quot;, j_data[&quot;data&quot;].get&lt;std::string&gt;().size());&#10;                //                    if (j_data.contains(&quot;consts&quot;)) fprintf(stderr, &quot; consts_len=%zu\n&quot;, j_data[&quot;consts&quot;].get&lt;std::string&gt;().size());&#10;                //                    if (j_data.contains(&quot;names&quot;)) fprintf(stderr, &quot; names_len=%zu\n&quot;, j_data[&quot;names&quot;].get&lt;std::string&gt;().size());&#10;                //                    if (j_data.contains(&quot;varnames&quot;)) fprintf(stderr, &quot; varnames_len=%zu\n&quot;, j_data[&quot;varnames&quot;].get&lt;std::string&gt;().size());&#10;                //                    if (j_data.contains(&quot;filename&quot;)) fprintf(stderr, &quot; filename_len=%zu\n&quot;, j_data[&quot;filename&quot;].get&lt;std::string&gt;().size());&#10;                //                    if (j_data.contains(&quot;name&quot;)) fprintf(stderr, &quot; name_len=%zu\n&quot;, j_data[&quot;name&quot;].get&lt;std::string&gt;().size());&#10;                //                    if (j_data.contains(&quot;lnotab&quot;)) fprintf(stderr, &quot; lnotab_len=%zu\n&quot;, j_data[&quot;lnotab&quot;].get&lt;std::string&gt;().size());&#10;                //                    if (j_data.contains(&quot;qualname&quot;)) fprintf(stderr, &quot; qualname_len=%zu\n&quot;, j_data[&quot;qualname&quot;].get&lt;std::string&gt;().size());&#10;                //                    throw;&#10;                //                }&#10;                //                node.meta.func_code = base64::encode(&#10;                //                    std::vector&lt;uint8_t&gt;(dump_str.begin(), dump_str.end())&#10;                //                );&#10;                // Use Python's marshal.dumps(code_obj) to obtain a bytes blob.&#10;                // We call it via the Python C-API (import marshal and call dumps).&#10;                node.meta.func_code.clear();&#10;                PyObject *marshal_mod = PyImport_ImportModule(&quot;marshal&quot;);&#10;                if (marshal_mod) {&#10;                    PyObject *dumps = PyObject_GetAttrString(marshal_mod, &quot;dumps&quot;);&#10;                    if (dumps &amp;&amp; PyCallable_Check(dumps)) {&#10;                        PyObject *marshalled = PyObject_CallFunctionObjArgs(dumps, code_obj, nullptr);&#10;                        if (marshalled) {&#10;                            if (PyBytes_Check(marshalled)) {&#10;                                char *mdata = PyBytes_AsString(marshalled);&#10;                                Py_ssize_t mlen = PyBytes_Size(marshalled);&#10;                                std::vector&lt;uint8_t&gt; marsh_vec;&#10;                                marsh_vec.assign(reinterpret_cast&lt;unsigned char *&gt;(mdata), reinterpret_cast&lt;unsigned char *&gt;(mdata) + mlen);&#10;                                node.meta.func_code = base64::encode(marsh_vec);&#10;                            }&#10;                            Py_DECREF(marshalled);&#10;                        }&#10;                    }&#10;                    Py_XDECREF(dumps);&#10;                    Py_DECREF(marshal_mod);&#10;                }&#10;                 // DECREF attribute objects we created&#10;                 Py_XDECREF(argcount);&#10;                 Py_XDECREF(posonlyargcount);&#10;                 Py_XDECREF(kwonlyargcount);&#10;                 Py_XDECREF(nlocals);&#10;                 Py_XDECREF(stacksize);&#10;                 Py_XDECREF(flags);&#10;                 Py_XDECREF(firstlineno);&#10;                 Py_XDECREF(qualname);&#10;            }&#10;            Py_XDECREF(code_bytes);&#10;            Py_XDECREF(consts);&#10;            Py_XDECREF(names);&#10;            Py_XDECREF(varnames);&#10;            Py_XDECREF(filename);&#10;            Py_XDECREF(name_co);&#10;            Py_XDECREF(lnotab);&#10;            Py_XDECREF(freevars);&#10;            Py_XDECREF(cellvars);&#10;            Py_XDECREF(code_obj);&#10;        }&#10;        PyObject *closure = PyObject_GetAttrString(obj, &quot;__closure__&quot;);&#10;        if (closure &amp;&amp; closure != Py_None) {&#10;            Py_ssize_t n_cells = PyTuple_Size(closure);&#10;            for (Py_ssize_t i = 0; i &lt; n_cells; i++) {&#10;                PyObject *cell = PyTuple_GetItem(closure, i);&#10;                if (PyObject *cell_contents = PyObject_GetAttrString(cell, &quot;cell_contents&quot;)) {&#10;                    uint32_t cell_id = serialize_recursive(&#10;                        cell_contents, graph, visited, depth + 1&#10;                    );&#10;                    PointerInfo ptr;&#10;                    ptr.from_node_id = owner_node_id;&#10;                    ptr.from_chunk_id = 0;&#10;                    ptr.offset = 0;&#10;                    ptr.to_node_id = cell_id;&#10;                    ptr.field_name = &quot;closure:&quot; + std::to_string(i);&#10;                    node.pointers.push_back(ptr);&#10;                    graph.all_pointers.push_back(ptr);&#10;                    Py_DECREF(cell_contents);&#10;                }&#10;            }&#10;        }&#10;        Py_XDECREF(closure);&#10;        return node;&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_module(PyObject *obj) {&#10;        SerializedNode node;&#10;        node.type = NodeType::MODULE;&#10;        node.meta.type_name = &quot;module&quot;;&#10;        node.meta.refcount = 1;&#10;        node.meta.total_size = 0;&#10;        node.meta.has_dict = false;&#10;        PyObject *name = PyObject_GetAttrString(obj, &quot;__name__&quot;);&#10;        if (name) {&#10;            node.meta.module_name = PyUnicode_AsUTF8(name);&#10;            Py_DECREF(name);&#10;        }&#10;        return node;&#10;    }&#10;&#10;    SerializedNode PyObjectSerializer::serialize_custom(&#10;        PyObject *obj,&#10;        SerializedGraph &amp;graph,&#10;        std::unordered_map&lt;PyObject *, uint32_t&gt; &amp;visited,&#10;        int depth,&#10;        uint32_t owner_node_id&#10;    ) {&#10;        SerializedNode node;&#10;        node.type = NodeType::CUSTOM;&#10;        node.meta.refcount = 1;&#10;        PyTypeObject *type = Py_TYPE(obj);&#10;        node.meta.type_name = type-&gt;tp_name;&#10;        PyObject *module = PyObject_GetAttrString(reinterpret_cast&lt;PyObject *&gt;(type), &quot;__module__&quot;);&#10;        if (module &amp;&amp; PyUnicode_Check(module)) {&#10;            node.meta.module_name = PyUnicode_AsUTF8(module);&#10;        }&#10;        node.meta.total_size = 0;&#10;        node.meta.has_dict = false;&#10;        Py_XDECREF(module);&#10;        if (PyObject_HasAttrString(obj, &quot;__dict__&quot;)) {&#10;            PyObject *dict = PyObject_GetAttrString(obj, &quot;__dict__&quot;);&#10;            if (dict &amp;&amp; PyDict_Check(dict)) {&#10;                node.meta.has_dict = true;&#10;                PyObject *key, *value;&#10;                Py_ssize_t pos = 0;&#10;                while (PyDict_Next(dict, &amp;pos, &amp;key, &amp;value)) {&#10;                    if (!PyUnicode_Check(key)) continue;&#10;                    const char *attr_name = PyUnicode_AsUTF8(key);&#10;                    uint32_t value_id = serialize_recursive(value, graph, visited, depth + 1);&#10;                    if (value_id != UINT32_MAX) {&#10;                        node.meta.attr_names.emplace_back(attr_name);&#10;                        node.meta.attr_node_ids[attr_name] = value_id;&#10;                        PointerInfo ptr;&#10;                        ptr.from_node_id = owner_node_id;&#10;                        ptr.from_chunk_id = 0;&#10;                        ptr.offset = 0;&#10;                        ptr.to_node_id = value_id;&#10;                        ptr.field_name = attr_name;&#10;                        node.pointers.push_back(ptr);&#10;                        graph.all_pointers.push_back(ptr);&#10;                    }&#10;                }&#10;            }&#10;            Py_XDECREF(dict);&#10;        }&#10;        return node;&#10;    }&#10;&#10;    SerializedGraph PyObjectSerializer::serialize(PyObject *obj) {&#10;        SerializedGraph graph;&#10;        std::unordered_map&lt;PyObject *, uint32_t&gt; visited;&#10;        graph.root_id = serialize_recursive(obj, graph, visited, 0);&#10;        if (graph.root_id == UINT32_MAX) {&#10;            throw std::runtime_error(&quot;Serialization failed&quot;);&#10;        }&#10;        return graph;&#10;    }&#10;&#10;    uint32_t PyObjectSerializer::serialize_recursive(&#10;        PyObject *obj,&#10;        SerializedGraph &amp;graph,&#10;        std::unordered_map&lt;PyObject *, uint32_t&gt; &amp;visited,&#10;        int depth&#10;    ) {&#10;        if (depth &gt; MAX_DEPTH) {&#10;            PyErr_SetString(PyExc_ValueError, &quot;Object nesting too deep&quot;);&#10;            return UINT32_MAX;&#10;        }&#10;        auto it = visited.find(obj);&#10;        if (it != visited.end()) {&#10;            SerializedNode ref_node;&#10;            ref_node.node_id = next_node_id_++;&#10;            ref_node.type = NodeType::REFERENCE;&#10;            ref_node.meta.refcount = 0;&#10;            uint32_t ref_target = it-&gt;second;&#10;            std::vector&lt;uint8_t&gt; ref_data(sizeof(uint32_t));&#10;            std::memcpy(ref_data.data(), &amp;ref_target, sizeof(uint32_t));&#10;            ref_node.chunks = create_chunks(ref_data);&#10;            graph.nodes.push_back(ref_node);&#10;            return ref_node.node_id;&#10;        }&#10;        uint32_t current_id = next_node_id_++;&#10;        visited[obj] = current_id;&#10;        SerializedNode node;&#10;        // Assign the canonical node id immediately so any pointers created by&#10;        // per-type serializers use the correct from_node_id.&#10;        node.node_id = current_id;&#10;        if (obj == Py_None) {&#10;            node.type = NodeType::NONE;&#10;            node.meta.refcount = 1;&#10;        } else if (PyBool_Check(obj)) {&#10;            node.type = NodeType::BOOL;&#10;            node.meta.refcount = 1;&#10;            uint8_t val = (obj == Py_True) ? 1 : 0;&#10;            node.chunks = create_chunks({val});&#10;        } else if (PyLong_Check(obj)) {&#10;            node = serialize_int(obj);&#10;            node.node_id = current_id;&#10;        } else if (PyFloat_Check(obj)) {&#10;            node = serialize_float(obj);&#10;            node.node_id = current_id;&#10;        } else if (PyUnicode_Check(obj)) {&#10;            node = serialize_string(obj);&#10;            node.node_id = current_id;&#10;        } else if (PyBytes_Check(obj)) {&#10;            node = serialize_bytes(obj);&#10;            node.node_id = current_id;&#10;        } else if (PyList_Check(obj)) {&#10;            node = serialize_container(obj, NodeType::LIST, graph, visited, depth, current_id);&#10;            node.node_id = current_id;&#10;        } else if (PyTuple_Check(obj)) {&#10;            node = serialize_container(obj, NodeType::TUPLE, graph, visited, depth, current_id);&#10;            node.node_id = current_id;&#10;        } else if (PyDict_Check(obj)) {&#10;            node = serialize_dict(obj, graph, visited, depth, current_id);&#10;            node.node_id = current_id;&#10;        } else if (PySet_Check(obj)) {&#10;            node = serialize_container(obj, NodeType::SET, graph, visited, depth, current_id);&#10;            node.node_id = current_id;&#10;        } else if (PyFunction_Check(obj)) {&#10;            node = serialize_function(obj, graph, visited, depth, current_id);&#10;            node.node_id = current_id;&#10;        } else if (PyModule_Check(obj)) {&#10;            node = serialize_module(obj);&#10;            node.node_id = current_id;&#10;        } else if (PyObject_HasAttrString(obj, &quot;fileno&quot;)) {&#10;            PyErr_SetString(PyExc_TypeError,&#10;                            &quot;Cannot serialize file objects. Extract file descriptor manually.&quot;);&#10;            return UINT32_MAX;&#10;        } else {&#10;            node = serialize_custom(obj, graph, visited, depth, current_id);&#10;            node.node_id = current_id;&#10;        }&#10;        // node.node_id was set earlier to current_id; push the finalized node.&#10;        graph.nodes.push_back(node);&#10;        return current_id;&#10;    }&#10;} // namespace pyser&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>